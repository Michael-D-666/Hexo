<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>行测-言语理解</title>
      <link href="/Hexo/2025/01/05/%E8%A1%8C%E6%B5%8B-%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3/"/>
      <url>/Hexo/2025/01/05/%E8%A1%8C%E6%B5%8B-%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><ol><li><p>(2021)在一些特殊的大尺度实验研究中，原始数据无法重复测量，此时可以使用数据重复来验证研究结论的稳健性（比如在对气候变化的研究中，我们希望了解地球表面的温度在过去60年中是否真的上升了，但可利用的原始数据有限且不可能重新获取。为进行重复检验，不同的研究小组分别独立对原始数据进行不同方式的处理，最终验证了研究结论的稳健性。但是，此类研究无法进行严格意义上的重复试验，因此，还需要考虑其结论能否与其他来源的经验证据构成一致的科学说明。</p><p> 这段文字意在说明，在某些特殊的大尺度实验研究中：</p><p> <strong>A. 数据重复研究方法有独特价值</strong></p><p> B. 可利用的原始数据具有特殊性</p><p> C. 不同小组的分工合作十分重要</p><p> D. 所得到的结论往往存在局限性</p><blockquote><p>原文如果有对策选对策，如果没有对策，只有问题，则要体现问题。<font style="color:red">最后一句话虽然是“但是”，但只是对第一句话的补充与辅助说明，本意仍在说明第一句话</font></p></blockquote></li><li><p>(2019)中国近代考古学从理论方法到技术手段都是西方传入的，直到今天我们仍在不断吸收外来的新方法、新手段，这些并不妨碍我们在吸收、实践、消化、创新后形成自己的特色。中国近百年来的考古发掘都是中国学者独立完成的，其方法、理论、技术思路都获得了国际同行的高度认可；类似良渚这样可以成为世界遗产的考古遗址在中国并不少见，比如石峁、陶寺、二里头、三星堆、海昏侯墓等。这些就是中国考古人敢于在良渚古城申遗中提出中国有5000年文明史的底气和实力。</p><p> 这段文字主要介绍：</p><p> <strong>A. 考古成就对良渚古城申遗的支持</strong></p><p> B. 独立创新对中国考古学的重要性</p><p> C. 中国考古学近百年来的发展历程</p><p> D. 借鉴西方经验对考古研究的意义</p><blockquote><p>分总结构看，看尾句</p></blockquote></li><li><p>(2021)有人认为，“要强化制度执行力，加强制度执行的监督，切实把我国制度优势转化为治理效能”，就是深化监察与督查体制改革，以监察和督查提升治理效能。<br>事实上，监察和督查只是强化制度执行的一种方式。将国家制度优势转化为治理效能是一个过程，至少包括制度创设、有效执行、监督和反馈等环节，强化制度执行力也不能局限于监察、督查和问责，还应采取法制保障、德治引领等手段。</p><p> 这段文字意在：</p><p> A. 分析提升制度执行力的必要路径和有效方法</p><p> B. 说明如何将制度优势有效转化为国家治理效能</p><p> <strong>C. 纠正对监察和督查在强化制度执行中的作用的错误认识</strong></p><p> D. 强调法制保障和德治引领在强化制度执行中的重要作用</p><blockquote><p>D选项不对，最后一句话并不是想强调 法治保障和德治引领，而是想强调强化制度执行力有很多方面，这两个方面不一定是重点。</p></blockquote></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>毕设</title>
      <link href="/Hexo/2024/12/16/%E6%AF%95%E8%AE%BE/"/>
      <url>/Hexo/2024/12/16/%E6%AF%95%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Exploring-Progress-in-Multivariate-Time-SeriesForecasting-Comprehensive-Benchmarking-and-Heterogeneity-Analysis"><a href="#Exploring-Progress-in-Multivariate-Time-SeriesForecasting-Comprehensive-Benchmarking-and-Heterogeneity-Analysis" class="headerlink" title="Exploring Progress in Multivariate Time SeriesForecasting: Comprehensive Benchmarking and Heterogeneity Analysis"></a>Exploring Progress in Multivariate Time SeriesForecasting: Comprehensive Benchmarking and Heterogeneity Analysis</h2><blockquote><p>Advanced neural networks outperform basic ones on datasets with clear and stable temporal patterns, while basic neural networks suffer from under-fitting.<br>Basic neural networks generally outperform advanced ones on datasets with significant distribution drift and datasets with unclear patterns, while advanced neural networks suffer from over-fitting.</p></blockquote><p>优秀的神经网络模型在有明显特征的数据集上表现较好，在有严重分布漂移的数据集上，优秀的神经网络会在训练集上过拟合</p><p>latent-based 和 none-graph-based 的区别：latent要学习一个图结构然后通过卷积操作去动态维护节点之间的关系。像STNORM和STID就不用卷积操作，只进行学习</p><h2 id="Spatial-Temporal-Decoupled-Masked-Pre-training-for-Spatiotemporal-Forecasting"><a href="#Spatial-Temporal-Decoupled-Masked-Pre-training-for-Spatiotemporal-Forecasting" class="headerlink" title="Spatial-Temporal-Decoupled Masked Pre-training for Spatiotemporal Forecasting"></a>Spatial-Temporal-Decoupled Masked Pre-training for Spatiotemporal Forecasting</h2><h2 id="主要解决-spatialtemporal-mirage-dissimilar-input-time-series-followed-by-similar-future-values-similar-input-time-series-followed-by-dissimilar-future-values"><a href="#主要解决-spatialtemporal-mirage-dissimilar-input-time-series-followed-by-similar-future-values-similar-input-time-series-followed-by-dissimilar-future-values" class="headerlink" title="主要解决 spatialtemporal mirage :- dissimilar input time series followed by similar future values-  similar input time series followed by dissimilar future values"></a>主要解决 <code>spatialtemporal mirage</code> :<br>- dissimilar input time series followed by similar future values<br>-  similar input time series followed by dissimilar future values</h2><h2 id="BigST-Linear-Complexity-Spatio-Temporal-Graph-Neural-Network-for-Traffic-Forecasting-on-Large-Scale-Road-Networks"><a href="#BigST-Linear-Complexity-Spatio-Temporal-Graph-Neural-Network-for-Traffic-Forecasting-on-Large-Scale-Road-Networks" class="headerlink" title="BigST: Linear Complexity Spatio-Temporal Graph Neural Network for Traffic Forecasting on Large-Scale Road Networks"></a>BigST: Linear Complexity Spatio-Temporal Graph Neural Network for Traffic Forecasting on Large-Scale Road Networks</h2><p>主要解决 </p><ul><li>How to efficiently and effectively exploit knowledge over long-term historical time series?<br>both the model’s efficiency and effectiveness. </li><li>How to reduce the expensive quadratic complexity in learning latent graph structures?</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯备赛</title>
      <link href="/Hexo/2024/12/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/"/>
      <url>/Hexo/2024/12/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>dp 搜索 图论</p><ol><li><p>对列表进行多条件排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans.items() <span class="comment"># 将字典中的所有键值对取出</span></span><br><span class="line">videos = <span class="built_in">list</span>(ans)   <span class="comment"># 将键值对放进列表</span></span><br><span class="line">videos.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>])) <span class="comment"># x[1]表示value,x[0]表示key，先按value进行排序，再按key进行排序</span></span><br><span class="line">re_ans = [video[<span class="number">0</span>] <span class="keyword">for</span> video <span class="keyword">in</span> videos]</span><br></pre></td></tr></table></figure></li><li><p>python 只有小顶堆，大顶堆只能用相反数实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">heap.heapify(array) <span class="comment"># 将array转换为了小顶堆</span></span><br><span class="line"><span class="comment"># 小顶堆中放元组，默认按元组的第一个元素排序</span></span><br></pre></td></tr></table></figure></li><li><p>动态转移方程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">爬楼梯： f(x)=f(x-<span class="number">1</span>)+f(x-<span class="number">2</span>)</span><br><span class="line">爬楼梯花费： cur_cost = <span class="built_in">min</span>(cur_cost[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],cur_cost[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>])</span><br><span class="line">组合总和： f(x) =  f(x-nums[i])求和 <span class="comment">#(不止能向上爬1层或两层，能爬的楼梯数通过数组给出)</span></span><br><span class="line">珠宝的最高价值： dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j])+nums[i][j] (只能拿右侧或者下侧的物体，因此当前物体拿不拿取决于左边的物体和上边的物体)</span><br><span class="line">不同路径： dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>]+dp[i+<span class="number">1</span>][j]</span><br><span class="line">最小路径和 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j])+grid[i][j]</span><br><span class="line">下降路径最小和 dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j],dp[i][j+<span class="number">1</span>],dp[i][j+<span class="number">2</span>])</span><br><span class="line">零钱兑换 dp[i] = <span class="built_in">min</span>(com)+<span class="number">1</span>  com = dp[i-a], dp[i-b], dp[i-c] (用额外<span class="built_in">bool</span>数组判断是否可达，只有上一个点可达，当前点才可达。 a,b,c是硬币面值)</span><br><span class="line">零钱兑换<span class="number">2</span>： dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-nums[i]],j-nums[i]&gt;=<span class="number">0</span> <span class="keyword">else</span>: dp[i][j]=dp[i-<span class="number">1</span>][j] <span class="comment"># 注意这个必须空一行和一列0，因为dp[i][j]要用到相同一行前面的数，所以第一行不能通过赋值初始化，也要在动态规划中初始化</span></span><br></pre></td></tr></table></figure></li><li><p>python 二维数组的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></li><li><p>输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment">#单行单个输入</span></span><br><span class="line">x, y, w, h = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())  <span class="comment">#单行多个输入</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):   <span class="comment"># 多行多个输入a</span></span><br><span class="line">     x, y, w, h = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>&amp; 和 and</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> dfs(i-<span class="number">1</span>,j) &amp; dfs(i+<span class="number">1</span>,j) &amp; dfs(i,j-<span class="number">1</span>) &amp; dfs(i,j+<span class="number">1</span>)</span><br><span class="line"><span class="comment">#如果用and，只要有False，后面就不会计算</span></span><br></pre></td></tr></table></figure></li><li><p>计算数组中数字出现的频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group = collections.Counter(arr)</span><br><span class="line">freq = group.most_common()[::-<span class="number">1</span>] <span class="comment"># [::-1]用于翻转列表，默认从高到低</span></span><br><span class="line">---</span><br><span class="line">dic=&#123;&#125;</span><br><span class="line">dic = <span class="built_in">sorted</span>(dic.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])<span class="comment"># 也可以直接用字典，按值排序</span></span><br></pre></td></tr></table></figure></li><li><p>DFS边图的计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edges = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> connections:</span><br><span class="line">   edges[x].append(y)</span><br><span class="line">   edges[y].append(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>生成三角列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">triangle = [[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row + <span class="number">1</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计算组合数</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">m, k</span>):</span><br><span class="line">   <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> k == m:</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> k &gt; m:</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   res = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">      res = res * (m - i) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否包含子串</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Contains(s, <span class="string">&quot;ba&quot;</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">if</span> ba <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></li><li><p>自定义快排</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr, low, high</span>):</span><br><span class="line"> <span class="keyword">if</span> low &lt; high:</span><br><span class="line">     <span class="comment"># 分区逻辑</span></span><br><span class="line">     pivot = arr[low]  <span class="comment"># 选择最左边的元素作为基准</span></span><br><span class="line">     i, j = low, high</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> i &lt; j:</span><br><span class="line">         <span class="comment"># 从右往左找第一个小于等于基准的元素</span></span><br><span class="line">         <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> fbig(arr[j], pivot):</span><br><span class="line">             j -= <span class="number">1</span></span><br><span class="line">         <span class="comment"># 从左往右找第一个大于基准的元素</span></span><br><span class="line">         <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> fbig(arr[i], pivot):</span><br><span class="line">             i += <span class="number">1</span></span><br><span class="line">         arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># 将基准元素放到正确的位置</span></span><br><span class="line">     arr[low], arr[i] = arr[i], arr[low]</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># 递归排序左半部分和右半部分</span></span><br><span class="line">     quick_sort(arr, low, i - <span class="number">1</span>)</span><br><span class="line">     quick_sort(arr, i + <span class="number">1</span>, high)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>进制转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>()  <span class="comment"># 十进制转2进制: </span></span><br><span class="line"><span class="built_in">oct</span>() <span class="comment"># 十进制转八进制 </span></span><br><span class="line"><span class="built_in">hex</span>()  <span class="comment"># 十进制转十六进制 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>字符串次数统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">dict</span>(collections.Counter(nums))</span><br></pre></td></tr></table></figure></li><li><p>大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.upper()</span><br><span class="line">a.lower()</span><br></pre></td></tr></table></figure></li><li><p>反转字符串和列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(n)) <span class="comment">#字符串反转</span></span><br><span class="line">a.reverse() <span class="comment"># 列表反转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>列表在指定位置插入元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret.insert(index[i], nums[i])</span><br></pre></td></tr></table></figure></li><li><p>遍历defautdict键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> c.items():</span><br></pre></td></tr></table></figure></li><li><p>差分数组</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> nums:</span><br><span class="line"> diff[x] += <span class="number">1</span></span><br><span class="line"> diff[y + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;songs_origin.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># print(df) # 输出一个二维csv表格</span></span><br><span class="line"><span class="built_in">print</span>(df.mean()) <span class="comment"># 默认对每一列求平均值</span></span><br><span class="line">df = df.fillna(df.mean()) <span class="comment"># 用平均值填充nan,注意赋值</span></span><br><span class="line">df = df[(df[<span class="string">&#x27;acousticness_yr&#x27;</span>]&lt;=<span class="number">1</span>) &amp; (df[<span class="string">&#x27;acousticness_yr&#x27;</span>]&gt;=<span class="number">0</span>)] <span class="comment"># 通过bool筛选</span></span><br><span class="line">df = df.drop_duplicates() <span class="comment"># 注意赋值</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;songs_processed.csv&#x27;</span>,index=<span class="literal">False</span>) <span class="comment"># 不保存标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>index_img踩坑</title>
      <link href="/Hexo/2024/12/08/index-img%E8%B8%A9%E5%9D%91/"/>
      <url>/Hexo/2024/12/08/index-img%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="踩坑1："><a href="#踩坑1：" class="headerlink" title="踩坑1："></a>踩坑1：</h2><p>由于 <code>Github Page</code>的仓库名没有设置为用户名，导致在访问网址的时候再github.io后面有后缀。在设置index_img的时候也要加上 <code>/仓库名/image/xxx.jpg</code>。但在设施 avatar的时候却不用，会自动加上</p><h2 id="踩坑2"><a href="#踩坑2" class="headerlink" title="踩坑2"></a>踩坑2</h2><p>在source下面新建image文件夹后，使用 <code>hexo g</code>命令后会自动在public中复制一份image文件夹，因此在修改的时候只要修改 <code>/source/image</code> 中的图片，修改了public中的图片也没有用处</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>行测-数量与资料分析</title>
      <link href="/Hexo/2024/12/07/%E8%A1%8C%E6%B5%8B-%E6%95%B0%E9%87%8F%E4%B8%8E%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/"/>
      <url>/Hexo/2024/12/07/%E8%A1%8C%E6%B5%8B-%E6%95%B0%E9%87%8F%E4%B8%8E%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h2><ol><li>列完不定方程后，若只能代入求解，则看题目中有无 <code>最大</code> <code>最小</code>字眼，可以从选项中选择最大值或最小值代入</li><li>复杂计算式子在实际问题中可能需要保证每一步算出来的都是整数 （p8例5）</li><li>不定方程两边可以通过奇偶判断，排除答案中奇偶错误的选项 （p10例1）</li><li>一个数能被4整除，当且仅当后两位能被4整除；一个数能被8整除，当且仅当后三位能被8整除</li><li>a占除a之外的1&#x2F;3，则a占总的1&#x2F;4 （p13例4）</li><li>不定方程中可以假设一项取值为0，算出其余项 （p28例10）</li><li>甲的效率比乙高25%，则设乙为8，甲为10</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Hexo/2024/12/04/hello-world/"/>
      <url>/Hexo/2024/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
